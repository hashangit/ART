# How to Connect Your UI to the ART Framework

This guide provides a comprehensive walkthrough for developers on how to use the ART Framework's public UI System API to build reactive and real-time user interfaces. You will learn how to access the UI sockets, subscribe to events, and fetch historical data to create a rich user experience.

## Prerequisites

Before you begin, you must complete two essential steps:

1.  **Create an `ArtInstance`**: This is the main entry point to the framework.
2.  **Set the `ThreadConfig` for a conversation**: You **must** configure each conversation thread (e.g., set the provider, model, API key, and enabled tools) *before* you can process messages or listen for events on that thread.

```javascript
import { createArtInstance, ThreadConfig } from 'art-framework';
import { artConfig } from './art.config.js'; // Your high-level instance configuration

let art;
const threadId = 'user-123-session-1'; // A unique ID for the conversation

async function initialize() {
  art = await createArtInstance(artConfig);
  
  // Define and set the configuration for the conversation thread
  const initialThreadConfig: ThreadConfig = {
    providerConfig: {
      providerName: 'openai',
      modelId: 'gpt-4o',
      adapterOptions: {
        apiKey: 'sk-your-real-openai-api-key' // Securely provide your API key
      }
    },
    enabledTools: ['CalculatorTool'],
    historyLimit: 50
  };

  await art.stateManager.setThreadConfig(threadId, initialThreadConfig);

  // Now you are ready to connect your UI for this specific threadId
}

initialize();
```

## 1. Accessing the UI System

The entry point to all UI-related functionality is the `uiSystem` object, which is a property of your `ArtInstance`.

```javascript
const uiSystem = art.uiSystem;
```

From this `uiSystem` object, you can get access to the individual sockets.

## 2. Understanding Sockets

The UI System is built on a **publish-subscribe** model. It exposes four specialized **sockets**, each acting as a dedicated channel for a specific type of data (e.g., chat messages, agent observations).

-   **Subscribing**: Your UI components can `subscribe` to a socket to listen for new data in real-time. When new data is available, a callback function you provide is executed.
-   **Unsubscribing**: Every `subscribe` call returns an `unsubscribe` function. It is crucial to call this function when your UI component unmounts to prevent memory leaks.
-   **Fetching History**: Most sockets have a `getHistory` method that allows you to retrieve a log of past data, which is essential for populating your UI when it first loads.

---

## 3. Connecting to the `ConversationSocket`

This is the most common socket, used for building chat interfaces.

### Getting the Socket

```javascript
const conversationSocket = art.uiSystem.getConversationSocket();
```

### Subscribing to New Messages

To display messages as they are sent by the user or generated by the agent, you subscribe to the socket. The callback will receive a `ConversationMessage` object.

```javascript
// Example: Displaying a new message in the chat window
const unsubscribe = conversationSocket.subscribe(
  (message) => {
    console.log('New message received:', message);
    // Code to append the message to your chat UI
    // e.g., addMessageToChat(message.content, message.role);
  },
  undefined, // No filter
  { threadId: 'user-123-session-1' } // VERY IMPORTANT: Always scope subscriptions to a thread
);

// When your component is destroyed, don't forget to unsubscribe:
// unsubscribe();
```

You can also filter messages by their role:

```javascript
// Only listen for messages from the AI
const unsubscribeFromAI = conversationSocket.subscribe(
  (message) => { /* ... */ },
  'AI', // Filter: a single MessageRole
  { threadId: 'user-123-session-1' }
);

// Only listen for messages from the USER or a TOOL
const unsubscribeFromUserOrTool = conversationSocket.subscribe(
  (message) => { /* ... */ },
  ['USER', 'TOOL'], // Filter: an array of MessageRole
  { threadId: 'user-123-session-1' }
);
```

### Fetching Message History

To load the existing chat history for a conversation, use `getHistory`.

```javascript
async function loadChatHistory(threadId) {
  try {
    const messages = await conversationSocket.getHistory(
      undefined, // No role filter
      {
        threadId: threadId,
        limit: 50 // Get the last 50 messages
      }
    );

    console.log(`Loaded ${messages.length} messages.`);
    // Code to render the historical messages in your UI
    // messages.forEach(msg => addMessageToChat(msg.content, msg.role));
  } catch (error) {
    console.error('Failed to load chat history:', error);
  }
}
```

---

## 4. Connecting to the `ObservationSocket`

This socket lets you visualize the agent's internal "thought process."

### Getting the Socket

```javascript
const observationSocket = art.uiSystem.getObservationSocket();
```

### Subscribing to New Observations

This is useful for showing a real-time feed of the agent's actions.

```javascript
// Example: Log any tool calls the agent makes
const unsubscribe = observationSocket.subscribe(
  (observation) => {
    if (observation.type === 'TOOL_CALL') {
      console.log('Agent is calling a tool:', observation.content);
      // Code to display the tool call in a "thought process" panel
    }
  },
  'TOOL_CALL', // Filter by the ObservationType
  { threadId: 'user-123-session-1' }
);

// Example: Listen for the final response to get structured UI metadata
const unsubscribeFinal = observationSocket.subscribe(
  (observation) => {
    if (observation.type === 'FINAL_RESPONSE') {
      const { message, uiMetadata } = observation.content;
      console.log('Final message:', message.content);
      console.log('UI Metadata for sources/suggestions:', uiMetadata);
      // Code to render sources and suggestions from the uiMetadata object
    }
  },
  'FINAL_RESPONSE',
  { threadId: 'user-123-session-1' }
);
```

### Fetching Observation History

You can retrieve past observations to show a complete log of a previous agent run.

```javascript
async function loadExecutionLog(threadId) {
  try {
    const observations = await observationSocket.getHistory(
      ['PLAN', 'TOOL_CALL', 'TOOL_EXECUTION', 'ERROR'], // Filter for specific types
      { threadId: threadId, limit: 100 }
    );

    console.log('Loaded execution log:', observations);
    // The `content` of the PLAN observation will be a structured array of steps.
    // The `content` of the FINAL_RESPONSE observation will contain the final message and uiMetadata.
    // Code to display the log in your UI
  } catch (error) {
    console.error('Failed to load execution log:', error);
  }
}
```

---

## 5. Connecting to the `LLMStreamSocket`

This socket is essential for creating a "typewriter" effect for the agent's response. Remember to set `stream: true` in your `art.process()` call to enable streaming.

### Getting the Socket

```javascript
const llmStreamSocket = art.uiSystem.getLLMStreamSocket();
```

### Subscribing to Stream Events

You'll typically subscribe to `TOKEN` events to append text to the UI in real-time.

```javascript
let finalMessage = '';
const unsubscribe = llmStreamSocket.subscribe(
  (streamEvent) => {
    switch (streamEvent.type) {
      case 'TOKEN':
        // Differentiate between thoughts and the final response
        if (streamEvent.tokenType === 'FINAL_SYNTHESIS_LLM_RESPONSE') {
          const token = streamEvent.data;
          finalMessage += token;
          // Code to update the last message in the UI with the new token
          // e.g., updateLastMessage(finalMessage);
        }
        break;
      case 'END':
        console.log('Stream ended. Final message:', finalMessage);
        // The stream is complete. You might save the final message to your state here.
        break;
      case 'ERROR':
        console.error('An error occurred during streaming:', streamEvent.data);
        break;
    }
  },
  undefined, // No filter
  { threadId: 'user-123-session-1' } // Scope to the correct thread
);
```

### Fetching History

The `LLMStreamSocket` does not have a `getHistory` method, as stream events are transient and not saved to the database.

---

## 6. Connecting to the `A2ATaskSocket`

This socket is for advanced applications that involve multiple agents delegating tasks to one another.

### Getting the Socket

```javascript
const a2aTaskSocket = art.uiSystem.getA2ATaskSocket();
```

### Subscribing to Task Updates

This allows you to build a real-time task management dashboard.

```javascript
// Example: Listen for any task that gets completed or fails
const unsubscribe = a2aTaskSocket.subscribe(
  (taskEvent) => {
    console.log(`Task ${taskEvent.task.taskId} moved to status: ${taskEvent.task.status}`);
    // Code to update the task's status in your dashboard UI
  },
  {
    // Rich filter object
    status: ['COMPLETED', 'FAILED']
  },
  { threadId: 'user-123-session-1' }
);
```

### Fetching Task History

You can load all existing tasks that match certain criteria.

```javascript
async function loadInProgressTasks(threadId) {
  try {
    const tasks = await a2aTaskSocket.getHistory(
      { status: 'IN_PROGRESS' }, // Filter
      { threadId: threadId }    // Options
    );

    console.log('Loaded in-progress tasks:', tasks);
    // Code to display these tasks in your UI
  } catch (error) {
    console.error('Failed to load in-progress tasks:', error);
  }
}
```
