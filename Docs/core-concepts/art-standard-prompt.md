# ArtStandardPrompt: The Universal LLM Input

A core design principle of the ART Framework is to provide a standardized way to interact with various Large Language Models (LLMs). The `ArtStandardPrompt` and its constituent `ArtStandardMessage` objects serve as this universal format for constructing prompts that are then translated by specific `ProviderAdapter`s into the native format required by each LLM provider.

## What are `ArtStandardPrompt` and `ArtStandardMessage`?

You can find their definitions in `src/types/index.ts`.

*   **`ArtStandardMessageRole`**: An enum defining the possible roles a message can have:
    *   `system`: Instructions or context for the AI, typically at the start.
    *   `user`: Input from the end-user or, in some cases (like Gemini with tool results), a wrapper for tool responses.
    *   `assistant`: Responses generated by the AI. Can include text and/or `tool_calls`.
    *   `tool_request`: (Less common for direct use) Represents the LLM's intent to use a tool, often implicitly part of an `assistant` message containing `tool_calls`.
    *   `tool_result` (or `tool`): The outcome (output or error) from a tool's execution. This is often translated to a `user` or `tool` role by adapters depending on the provider.

*   **`ArtStandardMessage`**: An interface representing a single message within the prompt.
    ```typescript
    export interface ArtStandardMessage {
      role: ArtStandardMessageRole;
      content: string | object | null; // Type depends on role
      name?: string;                   // For tool_result, the tool name
      tool_calls?: Array<{ /* ... */ }>; // For assistant role
      tool_call_id?: string;           // For tool_result role
    }
    ```
    *   `role`: One of the `ArtStandardMessageRole` values.
    *   `content`:
        *   For `system` and `user`: A `string` containing the instruction or query.
        *   For `assistant`: A `string` (the AI's text response) or `null` (if the assistant is only making `tool_calls`).
        *   For `tool_result` (or `tool`): A `string` representing the stringified JSON output or error message from the tool.
        *   For `tool_request`: An `object` or `null`.
    *   `name`: (Optional) Primarily used with `tool_result` to indicate the name of the tool that was executed.
    *   `tool_calls`: (Optional) An array of objects detailing tools the `assistant` wants to call. Each object includes:
        *   `id`: A unique ID for the tool call request.
        *   `type`: Typically `"function"`.
        *   `function`: An object with:
            *   `name`: The name of the tool/function.
            *   `arguments`: A **stringified JSON object** of arguments for the tool.
    *   `tool_call_id`: (Optional) Used in `tool_result` messages to link the result back to the specific `id` in the `assistant`'s `tool_calls`.

*   **`ArtStandardPrompt`**: This is simply an array of `ArtStandardMessage` objects, representing the complete, ordered sequence of messages to be sent to the LLM.
    ```typescript
    export type ArtStandardPrompt = ArtStandardMessage[];
    ```

## Why This Standard Format?

1.  **Provider Agnosticism:** Different LLM providers (OpenAI, Anthropic, Google Gemini, etc.) have their own unique API structures for sending prompts. `ArtStandardPrompt` acts as an intermediary abstraction. Agent logic (like `PESAgent`) constructs prompts in this standard format. Then, the selected `ProviderAdapter` (e.g., `OpenAIAdapter`, `AnthropicAdapter`) translates this standard prompt into the specific format required by its target LLM API.
2.  **Simplified Agent Logic:** Agent developers can focus on the *content* and *sequence* of interactions (system instructions, user queries, AI responses, tool interactions) without worrying about the low-level formatting details of each LLM provider.
3.  **Consistency:** Ensures a consistent way of representing conversational turns and tool interactions within the ART framework.

## How `PESAgent` Constructs `ArtStandardPrompt`

The `PESAgent` (Plan-Execute-Synthesize Agent) is responsible for constructing `ArtStandardPrompt` objects during its planning and synthesis phases. It does this directly by creating JavaScript arrays of `ArtStandardMessage` objects.

**Example: Planning Phase in `PESAgent` (Conceptual)**

```typescript
// Inside PESAgent.process() during planning:

// 1. Get system prompt
const systemPromptContent = await this.deps.stateManager.getThreadConfigValue<string>(props.threadId, 'systemPrompt') || this.defaultSystemPrompt;

// 2. Get formatted history
const formattedHistory = this.formatHistoryForPrompt(rawHistory); // Converts ConversationMessage[]

// 3. Get available tools and format them for the prompt
const toolsDescription = availableTools.map(tool =>
    `- ${tool.name}: ${tool.description}\n  Input Schema: ${JSON.stringify(tool.inputSchema)}`
).join('\n');

// 4. Construct the planning prompt
const planningPrompt: ArtStandardPrompt = [
    { role: 'system', content: systemPromptContent },
    ...formattedHistory,
    {
        role: 'user',
        content: `User Query: ${props.query}\n\nAvailable Tools:\n${toolsDescription}\n\nBased on the user query and conversation history, identify the user's intent and create a plan... Respond in the following format:\nIntent: ...\nPlan: ...\nTool Calls: ...`
    }
];

// 5. Validate (optional, but good practice if PromptManager is used)
// this.deps.promptManager.validatePrompt(planningPrompt);

// 6. Send to ReasoningEngine
// const planningStream = await this.deps.reasoningEngine.call(planningPrompt, planningOptions);
```
*(See `src/core/agents/pes-agent.ts` for the actual implementation details.)*

The `PESAgent` follows a similar process for constructing the `synthesisPrompt`, incorporating the results of tool executions into the prompt context.

## Example of a Complete `ArtStandardPrompt` (with Tool Use)

This example shows what an `ArtStandardPrompt` might look like when an agent is about to synthesize a response after using a tool:

```json
[
  {
    "role": "system",
    "content": "You are a helpful weather assistant."
  },
  {
    "role": "user",
    "content": "What's the weather like in London?"
  },
  {
    "role": "assistant",
    "content": null, // Assistant decided to use a tool, no immediate text response
    "tool_calls": [
      {
        "id": "call_weather_london_123",
        "type": "function",
        "function": {
          "name": "get_weather",
          "arguments": "{\"location\":\"London, UK\"}"
        }
      }
    ]
  },
  {
    "role": "tool_result", // Could also be 'tool' depending on internal representation before adapter translation
    "tool_call_id": "call_weather_london_123",
    "name": "get_weather", // Tool name often included for clarity or by some providers
    "content": "{\"temperature\": \"15°C\", \"condition\": \"Partly Cloudy\"}" // Stringified JSON result
  }
  // The next message in the prompt for the LLM would likely be a user-role message (constructed by the agent)
  // asking it to synthesize this information, or the agent might directly construct an assistant message
  // with the synthesized response.
  // For PESAgent, the synthesis prompt would include the above history and then a final user message like:
  // {
  //   "role": "user",
  //   "content": "User Query: What's the weather like in London?\n\nOriginal Intent: Find weather in London.\nExecution Plan: Use get_weather tool.\n\nTool Execution Results:\n- Tool: get_weather (Call ID: call_weather_london_123)\n  Status: success\n  Output: {\"temperature\": \"15°C\", \"condition\": \"Partly Cloudy\"}\n\nBased on the user query, the plan, and the results of any tool executions, synthesize a final response to the user."
  // }
]
```

## Role of `PromptManager`

While agent logic (like `PESAgent`) is responsible for *assembling* the `ArtStandardPrompt` object, the `PromptManager` can assist by:

1.  **Providing Reusable Fragments:** Using `promptManager.getFragment("fragment_name")` to fetch common instructions or templates that can be embedded into the `content` of `ArtStandardMessage` objects.
2.  **Validating Prompts:** Using `promptManager.validatePrompt(promptObject)` to ensure the constructed `ArtStandardPrompt` adheres to the expected schema (defined in `src/types/schemas.ts` using Zod). This helps catch structural errors early.

By adhering to `ArtStandardPrompt`, ART framework components can communicate effectively, and developers can build more robust and adaptable AI agents.