# Agents in ART

In the ART Framework, an **Agent** is the core component responsible for orchestrating the entire process of receiving input, reasoning, potentially using tools, and generating a response. It embodies the "brain" of your AI application.

## The `IAgentCore` Interface

All agent implementations in ART adhere to the `IAgentCore` interface (defined in `src/core/interfaces.ts`). This interface is simple but powerful:

```typescript
export interface IAgentCore {
  process(props: AgentProps): Promise<AgentFinalResponse>;
}
```

*   **`process(props: AgentProps): Promise<AgentFinalResponse>`:**
    *   This is the main entry point for interacting with an agent.
    *   `AgentProps`: An object containing the necessary input for the agent, such as:
        *   `query`: The user's input or question.
        *   `threadId`: A unique identifier for the current conversation thread.
        *   `userId` (optional): Identifier for the user.
        *   `traceId` (optional): For tracing requests across systems.
        *   `options` (optional): Runtime overrides, including `providerConfig` to select the LLM for this call.
    *   `AgentFinalResponse`: A promise that resolves to an object containing:
        *   `response`: The final `ConversationMessage` generated by the AI.
        *   `metadata`: An `ExecutionMetadata` object summarizing the agent's execution cycle (duration, LLM calls, tool calls, status, errors).

## `PESAgent`: Plan-Execute-Synthesize

ART provides a default agent implementation called `PESAgent` (`src/core/agents/pes-agent.ts`). "PES" stands for **Plan-Execute-Synthesize**, which describes its three-stage operational flow:

1.  **Plan:**
    *   **Goal:** Understand the user's query and the conversational context. Formulate an intent and a step-by-step plan to address the query. This plan might involve deciding to use one or more available tools.
    *   **Process:**
        *   Loads current `ThreadContext` (config & state) via `StateManager` and conversation `history` via `ConversationManager`.
        *   Constructs a planning prompt (`ArtStandardPrompt`) including the system prompt, history, user query, and a description of available tools.
        *   Calls the `ReasoningEngine` with this prompt (requesting a streaming response).
        *   Consumes the `StreamEvent`s from the LLM. The accumulated text output from this planning call is then parsed by the `OutputParser`.
        *   The `OutputParser` extracts the `intent`, `plan` description, and any `ParsedToolCall`s (requests to use tools).
        *   Observations like `INTENT`, `PLAN`, and `TOOL_CALL` are recorded.

2.  **Execute:**
    *   **Goal:** If the planning phase identified any tools to be used, this stage executes them.
    *   **Process:**
        *   The `ParsedToolCall`s are passed to the `ToolSystem`.
        *   The `ToolSystem` verifies if each tool is enabled (via `StateManager`), retrieves the tool's executor from the `ToolRegistry`, validates the arguments against the tool's `ToolSchema`, and then calls the tool's `execute` method.
        *   The `ToolResult` (success or error) for each tool call is collected.
        *   `TOOL_EXECUTION` observations are recorded by the `ToolSystem`.

3.  **Synthesize:**
    *   **Goal:** Generate a final, coherent, user-facing response based on the original query, the plan, and the results from any executed tools.
    *   **Process:**
        *   Constructs a synthesis prompt (`ArtStandardPrompt`). This prompt includes the system prompt, history, original query, the generated plan, and the `ToolResult`s.
        *   Calls the `ReasoningEngine` with this synthesis prompt (requesting a streaming response).
        *   Consumes the `StreamEvent`s. The accumulated text from `TOKEN` events (specifically those with `tokenType` indicating final synthesis) forms the final AI response.
        *   `SYNTHESIS` observations are recorded.

**Lifecycle and Dependencies:**

The `PESAgent` (and any `IAgentCore` implementation) is instantiated by the `AgentFactory` (used internally by `createArtInstance`). The factory injects all necessary dependencies:

*   `StateManager`
*   `ConversationManager`
*   `ToolRegistry`
*   `ReasoningEngine`
*   `OutputParser`
*   `ObservationManager`
*   `ToolSystem`
*   `UISystem`

This dependency injection allows the agent to focus on its orchestration logic without being tightly coupled to the concrete implementations of these underlying systems.

## Agent Lifecycle (Conceptual)

1.  **Initialization (`createArtInstance`):**
    *   The application provides an `ArtInstanceConfig`.
    *   `AgentFactory` initializes all systems (storage, managers, engines, registries) based on this config.
    *   An instance of the configured `IAgentCore` (e.g., `PESAgent`) is created and wired with these initialized systems.
    *   An `ArtInstance` object is returned, providing the `process` method.

2.  **Processing a Query (`artInstance.process(props)`):**
    *   The application calls `artInstance.process()` with `AgentProps`.
    *   The `IAgentCore` (e.g., `PESAgent`) executes its defined flow (like Plan-Execute-Synthesize).
    *   Throughout the process, interactions with LLMs, tools, and context management occur.
    *   Observations are recorded.
    *   UI sockets are notified of events (new messages, LLM stream tokens, observations).
    *   The agent returns an `AgentFinalResponse`.

3.  **State & History Persistence:**
    *   `ConversationManager` saves new messages to the configured `StorageAdapter`.
    *   `StateManager` saves `AgentState` based on the `StateSavingStrategy` (either explicitly via `setAgentState` or implicitly via `saveStateIfModified` if changes are detected after `loadThreadContext`).

ART's agent architecture provides a structured yet flexible way to build sophisticated AI applications. While `PESAgent` is the default, developers can implement custom `IAgentCore` to realize different reasoning patterns or agent behaviors.