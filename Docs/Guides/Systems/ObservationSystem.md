# Observation System Guide (v0.2.4)

## Overview

The Observation System (OS) is a critical component of the Agent Runtime (ART) Framework designed to provide **transparency** and **traceability** into the agent's internal operations. As the agent executes its reasoning pattern (like Plan-Execute-Synthesize), the Observation System records significant events as structured `Observation` objects.

These observations serve multiple purposes:

*   **Debugging:** Developers can inspect the sequence of observations to understand the agent's decision-making process and pinpoint issues.
*   **Monitoring:** Track agent performance, tool usage, and error rates.
*   **UI Feedback:** Provide real-time updates to the user about what the agent is doing (e.g., "Thinking...", "Using Calculator Tool...", "Planning complete").
*   **Analysis:** Persisted observations can be analyzed later to evaluate agent behavior and identify areas for improvement.

## Core Components

1.  **`ObservationManager`**:
    *   **Purpose:** The primary service for creating, recording, and retrieving observations.
    *   **Key Role:** Provides a `record` method used by other systems (Agent Core, Reasoning System, Tool System) to log events. It assigns unique IDs and timestamps, coordinates persistence via the `ObservationRepository`, and notifies the `UISystem` (`ObservationSocket`). It also provides a method to retrieve historical observations.
    *   **Interaction:** Uses `ObservationRepository` for storage and `ObservationSocket` for notifications.

2.  **`ObservationRepository`**:
    *   **Purpose:** Handles the actual persistence of `Observation` objects.
    *   **Key Role:** Abstracts the storage mechanism by using the configured `StorageAdapter` (e.g., `IndexedDBStorageAdapter`, `InMemoryStorageAdapter`).
    *   **Interaction:** Called by `ObservationManager` to save and retrieve observations.

## The `Observation` Structure

Every recorded event is captured as an `Observation` object with a standardized structure:

```typescript
import { ObservationType } from 'art-framework'; // Assuming ObservationType enum is exported

interface Observation {
  /** Unique identifier for this specific observation record. */
  id: string; 

  /** The thread this observation belongs to. Essential for filtering. */
  threadId: string; 

  /** Optional trace ID for correlating observations across different systems or calls. */
  traceId?: string; 

  /** Unix timestamp (in milliseconds) when the observation was recorded. */
  timestamp: number; 

  /** The category of the event being observed. */
  type: ObservationType; 

  /** A concise, human-readable title summarizing the observation. */
  title: string; 

  /** The main data payload of the observation. Structure varies by type. */
  content: any; 

  /** Additional contextual metadata (e.g., source phase, model used, tool name). */
  metadata?: Record<string, any>; 
}
```

## Standard Observation Types (`ObservationType`)

ART v0.2.4 defines several standard observation types generated during the PES execution flow:

*   **`INTENT`**: Records the agent's interpreted intent based on the user query (generated during Planning).
    *   `content`: Typically a string representing the intent.
*   **`PLAN`**: Records the step-by-step plan formulated by the agent (generated during Planning).
    *   `content`: Usually a string containing the plan description, potentially including the raw `ParsedToolCall` objects.
*   **`THOUGHTS`**: Records intermediate reasoning steps streamed from the LLM (generated during Planning and Synthesis).
    *   `content`: A string containing the thought or reasoning fragment.
    *   `metadata`: Often includes `{ sourcePhase: 'planning' | 'synthesis' }`.
*   **`TOOL_EXECUTION`**: Records the attempt and result of executing a tool (generated by the Tool System).
    *   `content`: The full `ToolResult` object (`{ callId, toolName, status, output?, error?, metadata? }`).
    *   `metadata`: Often includes `{ toolName, callId, status }`.
*   **`ERROR`**: Records an error that occurred during any stage of the agent's execution.
    *   `content`: An object containing error details (e.g., `{ message: string, code?: ErrorCode, stack?: string }`).
    *   `metadata`: Often includes `{ component: string, phase: string }`.

Custom observation types can also be defined and recorded if needed for specific application logic.

## How Observations are Generated

Observations are not generated by the Observation System itself but are **recorded** by it when triggered by other systems:

*   **Agent Core (`PESAgent`)**: Records `INTENT` and `PLAN` after the planning LLM call and parsing. It also orchestrates the recording of `ERROR` observations if issues occur during the main flow.
*   **Reasoning System (`ReasoningEngine` / `ProviderAdapter`)**: Triggers the `onThought` callback during LLM calls, which the Agent Core typically wires to `ObservationManager.record` to create `THOUGHTS` observations. It might also trigger `ERROR` observations on API failures.
*   **Tool System (`ToolSystem`)**: Records `TOOL_EXECUTION` observations after each tool attempt (both success and failure). It captures the complete `ToolResult`.

## Recording Observations (`ObservationManager.record`)

The core method used by other systems to log events.

```typescript
interface ObservationManager {
  /**
   * Records a new observation. Assigns ID and timestamp automatically.
   * Persists the observation and notifies the UI system.
   * @param observationData - Data for the observation, excluding id and timestamp.
   */
  record(observationData: Omit<Observation, 'id' | 'timestamp' | 'title'>): Promise<void>;

  /**
   * Retrieves historical observations for a thread, optionally filtered.
   * @param threadId - The ID of the thread to retrieve observations for.
   * @param filter - Optional filter criteria (e.g., by type).
   */
  getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]>;
}

interface ObservationFilter {
  types?: ObservationType[];
  // Other potential filter criteria like time range...
}

// Example usage by ToolSystem:
async function recordToolExecution(toolResult: ToolResult, threadId: string, traceId?: string) {
  await observationManager.record({
    threadId: threadId,
    traceId: traceId,
    type: ObservationType.TOOL_EXECUTION,
    // Title might be generated automatically based on type/metadata
    content: toolResult, 
    metadata: { 
      toolName: toolResult.toolName, 
      callId: toolResult.callId,
      status: toolResult.status 
    } 
  });
}
```

The `record` method handles:
1.  Generating a unique `id` and `timestamp`.
2.  Generating a default `title` based on the `type` and `metadata` (can be overridden).
3.  Calling `ObservationRepository.save()` to persist the observation.
4.  Calling `ObservationSocket.notify()` to broadcast the observation to UI subscribers.

## Querying Observations (`ObservationManager.getObservations`)

You can retrieve past observations for analysis or display using `getObservations`, filtering by `threadId` and optionally by `ObservationType`.

```typescript
// Get all observations for a thread
const allObservations = await observationManager.getObservations('thread-123');

// Get only TOOL_EXECUTION and ERROR observations
const toolAndErrorObservations = await observationManager.getObservations('thread-123', {
  types: [ObservationType.TOOL_EXECUTION, ObservationType.ERROR]
});
```

## UI Integration (`ObservationSocket`)

The `ObservationManager` automatically notifies the `ObservationSocket` (part of the [UI System](./UISystem.md)) whenever a new observation is recorded. UI components can subscribe to this socket, filtering by `threadId` and `ObservationType`, to receive real-time updates.

```typescript
// Example UI subscription (conceptual)
const observationSocket = artInstance.uiSystem.getObservationSocket();

const unsubscribe = observationSocket.subscribe(
  (observation) => {
    // Update UI based on the observation type and content
    if (observation.type === ObservationType.THOUGHTS) {
      showThinkingIndicator(observation.content);
    } else if (observation.type === ObservationType.TOOL_EXECUTION) {
      showToolStep(observation.metadata.toolName, observation.content.status);
    } 
    // ... etc.
  },
  null, // No type filter (get all types)
  { threadId: 'current-thread-id' } // Filter for the specific thread
);

// Remember to call unsubscribe() when the component unmounts.
```

This enables building UIs that dynamically reflect the agent's internal state and progress.

## Related Guides

*   [UI System Guide](./UISystem.md)
*   [Storage System Guide](./StorageSystem.md)
*   [Agent Core Guide](./AgentCore.md)
*   [Reasoning System Guide](./ReasoningSystem.md)
*   [Tool System Guide](./ToolSystem.md)