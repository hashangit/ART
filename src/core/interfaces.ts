// src/core/interfaces.ts
import {
  AgentFinalResponse,
  AgentProps,
  CallOptions,
  ConversationMessage,
  ExecutionContext,
  FilterOptions,
  FormattedPrompt,
  MessageOptions,
  MessageRole, // Added import
  Observation,
  ObservationFilter,
  ObservationType,
  ParsedToolCall,
  ThreadConfig,
  ThreadContext,
  ToolResult,
  ToolSchema,
  AgentState // Added import
} from '../types'; // Assuming types are exported from src/types/index.ts

/**
 * Interface for the central agent orchestrator.
 */
export interface IAgentCore {
  /**
   * Processes a user query through the configured agent reasoning pattern (e.g., PES).
   * Orchestrates interactions between various ART subsystems.
   * @param props - The input properties for the agent execution, including the query, thread ID, and injected dependencies.
   * @returns A promise that resolves with the final agent response and execution metadata.
   * @throws {ARTError} If a critical error occurs during orchestration that prevents completion.
   */
  process(props: AgentProps): Promise<AgentFinalResponse>;
}

/**
 * Interface for the component responsible for interacting with LLMs.
 */
export interface ReasoningEngine {
  /**
   * Executes a call to the configured Large Language Model (LLM).
   * This method is typically implemented by a specific `ProviderAdapter`.
   * When streaming is requested via `options.stream`, it returns an AsyncIterable
   * that yields `StreamEvent` objects as they are generated by the LLM provider.
   * When streaming is not requested, it should still return an AsyncIterable
   * that yields a minimal sequence of events (e.g., a single TOKEN event with the full response,
   * a METADATA event if available, and an END event).
   * @param prompt - The prompt to send to the LLM, potentially formatted specifically for the provider.
   * @param options - Options controlling the LLM call, including mandatory `threadId`, tracing IDs, model parameters (like temperature), streaming preference, and call context.
   * @returns A promise resolving to an AsyncIterable of `StreamEvent` objects.
   * @throws {ARTError} If a critical error occurs during the initial call setup or if the stream itself errors out (typically code `LLM_PROVIDER_ERROR`).
   */
  call(prompt: FormattedPrompt, options: CallOptions): Promise<AsyncIterable<import("../types").StreamEvent>>;
}

/**
 * Interface for managing and constructing prompts for the LLM.
 */
export interface PromptManager {
  /**
   * Constructs the prompt specifically for the planning phase of an agent's execution cycle (e.g., in PES).
   * This prompt typically instructs the LLM to understand the query, form a plan, and identify necessary tool calls.
   * @param query - The user's original query.
   * @param history - Recent conversation history relevant to the current context.
   * @param systemPrompt - The base system instructions for the agent in this thread.
   * @param availableTools - An array of schemas for tools that are enabled and available for use in this thread.
   * @param threadContext - The full context (config and state) for the current thread.
   * @returns A promise resolving to the formatted prompt (string or provider-specific object) ready for the `ReasoningEngine`.
   */
  createPlanningPrompt(
    query: string,
    history: ConversationMessage[],
    systemPrompt: string | undefined,
    availableTools: ToolSchema[],
    threadContext: ThreadContext
  ): Promise<FormattedPrompt>;

  /**
   * Constructs the prompt specifically for the synthesis phase of an agent's execution cycle (e.g., in PES).
   * This prompt typically provides the LLM with the original query, the plan, tool results, and history, asking it to generate the final user-facing response.
   * @param query - The user's original query.
   * @param intent - The intent extracted during the planning phase.
   * @param plan - The plan generated during the planning phase.
   * @param toolResults - An array of results obtained from executing the tools specified in the plan.
   * @param history - Recent conversation history.
   * @param systemPrompt - The base system instructions for the agent.
   * @param threadContext - The full context (config and state) for the current thread.
   * @returns A promise resolving to the formatted prompt (string or provider-specific object) ready for the `ReasoningEngine`.
   */
  createSynthesisPrompt(
    query: string,
    intent: string | undefined, // Or a structured intent object
    plan: string | undefined, // Or a structured plan object
    toolResults: ToolResult[],
    history: ConversationMessage[],
    systemPrompt: string | undefined,
    threadContext: ThreadContext
  ): Promise<FormattedPrompt>;
}

/**
 * Interface for parsing structured output from LLM responses.
 */
export interface OutputParser {
  /**
   * Parses the raw string output from the planning LLM call to extract structured information.
   * Implementations should be robust to variations in LLM output formatting.
   * @param output - The raw string response from the planning LLM call.
   * @returns A promise resolving to an object containing the extracted intent, plan description, and an array of parsed tool calls.
   * @throws {ARTError} If the output cannot be parsed into the expected structure (typically code `OUTPUT_PARSING_FAILED`).
   */
  parsePlanningOutput(output: string): Promise<{
    intent?: string;
    plan?: string;
    toolCalls?: ParsedToolCall[];
  }>;

  /**
   * Parses the raw string output from the synthesis LLM call to extract the final, user-facing response content.
   * This might involve removing extraneous tags or formatting.
   * @param output - The raw string response from the synthesis LLM call.
   * @returns A promise resolving to the clean, final response string.
   * @throws {ARTError} If the final response cannot be extracted (typically code `OUTPUT_PARSING_FAILED`).
   */
  parseSynthesisOutput(output: string): Promise<string>;
}

/**
 * Base interface for LLM Provider Adapters, extending the core ReasoningEngine.
 * Implementations will handle provider-specific API calls, authentication, etc.
 */
export interface ProviderAdapter extends ReasoningEngine {
  // Provider-specific methods or properties might be added here if needed.
  // The 'call' method implementation will be provider-specific.
  /** The unique identifier name for this provider (e.g., 'openai', 'anthropic'). */
  readonly providerName: string;
}

/**
 * Interface for the executable logic of a tool.
 */
export interface IToolExecutor {
  /** The schema definition for this tool. */
  readonly schema: ToolSchema;

  /**
   * Executes the tool's logic.
   * @param input Validated input arguments matching the tool's inputSchema.
   * @param context Execution context containing threadId, traceId, etc.
   * @returns A promise resolving to the structured tool result.
   */
  execute(input: any, context: ExecutionContext): Promise<ToolResult>;
}

/**
 * Interface for managing the registration and retrieval of tools.
 */
export interface ToolRegistry {
  /**
   * Registers a tool executor instance, making it available for use.
   * @param executor - The instance of the class implementing `IToolExecutor`.
   * @throws {Error} If a tool with the same name is already registered.
   */
  registerTool(executor: IToolExecutor): Promise<void>;

  /**
   * Retrieves a registered tool executor instance by its unique name.
   * @param toolName - The `name` property defined in the tool's schema.
   * @returns A promise resolving to the executor instance, or `undefined` if no tool with that name is registered.
   */
  getToolExecutor(toolName: string): Promise<IToolExecutor | undefined>;

  /**
   * Retrieves the schemas of available tools. Can be filtered, e.g., to get only tools enabled for a specific thread.
   * @param filter - Optional filter criteria. If `enabledForThreadId` is provided, it should consult the `StateManager` to return only schemas for tools enabled in that thread's configuration.
   * @returns A promise resolving to an array of `ToolSchema` objects.
   */
  getAvailableTools(filter?: { enabledForThreadId?: string }): Promise<ToolSchema[]>;
}

/**
 * Interface for the system responsible for orchestrating tool execution.
 */
export interface ToolSystem {
  /**
   * Orchestrates the execution of a sequence of tool calls determined during the planning phase.
   * This involves verifying permissions, validating inputs, calling the tool executor, and recording observations.
   * @param toolCalls - An array of `ParsedToolCall` objects generated by the `OutputParser`.
   * @param threadId - The ID of the current thread, used for context and checking tool permissions via `StateManager`.
   * @param traceId - Optional trace ID for correlating observations.
   * @returns A promise resolving to an array of `ToolResult` objects, one for each attempted tool call (including errors).
   */
  executeTools(
    toolCalls: ParsedToolCall[],
    threadId: string,
    traceId?: string
  ): Promise<ToolResult[]>;
}

/**
 * Interface for managing thread-specific configuration and state.
 */
export interface StateManager {
  /**
   * Loads the complete context (`ThreadConfig` and `AgentState`) for a specific thread.
   * This is typically called at the beginning of an agent execution cycle.
   * @param threadId - The unique identifier for the thread.
   * @param userId - Optional user identifier, potentially used for retrieving user-specific state or config overrides.
   * @returns A promise resolving to the `ThreadContext` object containing the loaded configuration and state.
   * @throws {ARTError} If the context for the thread cannot be loaded (e.g., code `THREAD_NOT_FOUND`).
   */
  loadThreadContext(threadId: string, userId?: string): Promise<ThreadContext>;

  /**
   * Verifies if a specific tool is permitted for use within a given thread.
   * Checks against the `enabledTools` array in the thread's loaded `ThreadConfig`.
   * @param threadId - The ID of the thread.
   * @param toolName - The name of the tool to check.
   * @returns A promise resolving to `true` if the tool is enabled for the thread, `false` otherwise.
   */
  isToolEnabled(threadId: string, toolName: string): Promise<boolean>;

  /**
   * Retrieves a specific value from the thread's configuration (`ThreadConfig`).
   * Supports accessing nested properties using dot notation (e.g., 'reasoning.model').
   * @template T - The expected type of the configuration value.
   * @param threadId - The ID of the thread.
   * @param key - The key (potentially nested) of the configuration value to retrieve.
   * @returns A promise resolving to the configuration value, or `undefined` if the key doesn't exist or the thread config isn't loaded.
   */
  getThreadConfigValue<T>(threadId: string, key: string): Promise<T | undefined>;

  /**
   * Persists the `AgentState` for the thread, but only if it has been marked as modified during the current execution cycle.
   * This prevents unnecessary writes to the storage layer.
   * @param threadId - The ID of the thread whose state should potentially be saved.
   * @returns A promise that resolves when the save operation is complete (or skipped).
   */
  saveStateIfModified(threadId: string): Promise<void>;

  /**
   * Sets or completely replaces the configuration (`ThreadConfig`) for a specific thread.
   * Use with caution, as this overwrites the existing configuration. Consider methods for partial updates if needed.
   * @param threadId - The ID of the thread whose configuration is being set.
   * @param config - The complete `ThreadConfig` object to save.
   * @returns A promise that resolves when the configuration is saved.
   */
  setThreadConfig(threadId: string, config: ThreadConfig): Promise<void>;

  // Potentially add methods to update config/state if needed during runtime,
  // though v0.2.4 focuses on loading existing config.
  // updateAgentState(threadId: string, updates: Partial<AgentState>): Promise<void>;
}

/**
 * Interface for managing conversation history.
 */
export interface ConversationManager {
  /**
   * Appends one or more `ConversationMessage` objects to the history of a specific thread.
   * Typically called at the end of an execution cycle to save the user query and the final AI response.
   * @param threadId - The ID of the thread to add messages to.
   * @param messages - An array containing the `ConversationMessage` objects to add.
   * @returns A promise that resolves when the messages have been successfully added to storage.
   */
  addMessages(threadId: string, messages: ConversationMessage[]): Promise<void>;

  /**
   * Retrieves messages from a specific thread's history, usually in reverse chronological order.
   * @param threadId - The ID of the thread whose history is needed.
   * @param options - Optional parameters to control retrieval, such as `limit` (max number of messages) or `beforeTimestamp` (for pagination). See `MessageOptions` type.
   * @returns A promise resolving to an array of `ConversationMessage` objects, ordered according to the implementation (typically newest first if not specified otherwise).
   */
  getMessages(threadId: string, options?: MessageOptions): Promise<ConversationMessage[]>;

  // Optional: Method to clear history or prune based on limits might be useful.
  // clearHistory(threadId: string): Promise<void>;
}

/**
 * Interface for managing the recording and retrieval of observations.
 */
export interface ObservationManager {
  /**
   * Creates, persists, and broadcasts a new observation record.
   * This is the primary method used by other systems to log significant events.
   * It automatically generates a unique ID, timestamp, and potentially a title.
   * @param observationData - An object containing the core data for the observation (`threadId`, `type`, `content`, `metadata`, etc.), excluding fields generated by the manager (`id`, `timestamp`, `title`).
   * @returns A promise that resolves when the observation has been recorded and notified.
   */
  record(observationData: Omit<Observation, 'id' | 'timestamp' | 'title'>): Promise<void>;

  /**
   * Retrieves historical observations stored for a specific thread.
   * @param threadId - The ID of the thread whose observations are to be retrieved.
   * @param filter - Optional criteria to filter the observations, e.g., by `ObservationType`. See `ObservationFilter`.
   * @returns A promise resolving to an array of `Observation` objects matching the criteria.
   */
  getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]>;
}

/**
 * Generic interface for a typed publish/subscribe socket.
 */
export interface TypedSocket<DataType, FilterType = any> {
  /**
   * Subscribes a callback function to receive data updates.
   * @param callback The function to call with new data.
   * @param filter Optional filter criteria specific to the socket type.
   * @param options Optional configuration like target threadId.
   * @returns An unsubscribe function.
   */
  subscribe(
    callback: (data: DataType) => void,
    filter?: FilterType,
    options?: { threadId?: string }
  ): () => void; // Returns unsubscribe function

  /**
   * Notifies subscribers of new data.
   * @param data The data payload.
   * @param options Optional targeting information (e.g., specific thread).
   */
  notify(
    data: DataType,
    options?: { targetThreadId?: string; targetSessionId?: string }
  ): void;

  /**
   * Optional method to retrieve historical data from the socket's source.
   * @param filter Optional filter criteria.
   * @param options Optional configuration like threadId and limit.
   */
  getHistory?(
    filter?: FilterType,
    options?: { threadId?: string; limit?: number }
  ): Promise<DataType[]>;
}

/**
 * TypedSocket specifically for Observation data.
 * FilterType is ObservationType or array of ObservationType.
 */
export interface ObservationSocket extends TypedSocket<Observation, ObservationType | ObservationType[]> {}

/**
 * TypedSocket specifically for ConversationMessage data.
 * FilterType is MessageRole or array of MessageRole.
 */
export interface ConversationSocket extends TypedSocket<ConversationMessage, MessageRole | MessageRole[]> {}

// Import concrete socket classes for use in the UISystem interface return types
import { ObservationSocket as ObservationSocketImpl } from '../systems/ui/observation-socket';
import { ConversationSocket as ConversationSocketImpl } from '../systems/ui/conversation-socket';

/**
 * Interface for the system providing access to UI communication sockets.
 */
export interface UISystem {
  /** Returns the singleton instance of the ObservationSocket. */
  getObservationSocket(): ObservationSocketImpl;
  /** Returns the singleton instance of the ConversationSocket. */
  getConversationSocket(): ConversationSocketImpl;
  /** Returns the singleton instance of the LLMStreamSocket. */
  getLLMStreamSocket(): import("../systems/ui/llm-stream-socket").LLMStreamSocket;
  // TODO: Potentially add getStateSocket(): StateSocket; in the future
}

/**
 * Interface for a storage adapter, providing a generic persistence layer.
 */
export interface StorageAdapter {
  /** Optional initialization method (e.g., connecting to DB). */
  init?(config?: any): Promise<void>;

  /**
   * Retrieves a single item from a collection by its ID.
   * @param collection The name of the data collection (e.g., 'conversations', 'observations').
   * @param id The unique ID of the item.
   * @returns The item or null if not found.
   */
  get<T>(collection: string, id: string): Promise<T | null>;

  /**
   * Saves (creates or updates) an item in a collection.
   * @param collection The name of the collection.
   * @param id The unique ID of the item.
   * @param data The data to save.
   */
  set<T>(collection: string, id: string, data: T): Promise<void>;

  /**
   * Deletes an item from a collection by its ID.
   * @param collection The name of the collection.
   * @param id The unique ID of the item.
   */
  delete(collection: string, id: string): Promise<void>;

  /**
   * Queries items in a collection based on filter options.
   * @param collection The name of the collection.
   * @param filterOptions Filtering, sorting, and pagination options.
   * @returns An array of matching items.
   */
  query<T>(collection: string, filterOptions: FilterOptions): Promise<T[]>;

  /** Optional: Clears all items from a specific collection. */
  clearCollection?(collection: string): Promise<void>;

  /** Optional: Clears all data managed by the adapter. Use with caution! */
  clearAll?(): Promise<void>;
}

// --- Repository Interfaces ---
// These interfaces define how specific data types are managed, using a StorageAdapter internally.

/** Repository for managing ConversationMessages. */
export interface IConversationRepository {
  addMessages(threadId: string, messages: ConversationMessage[]): Promise<void>;
  getMessages(threadId: string, options?: MessageOptions): Promise<ConversationMessage[]>;
  // Potentially add deleteMessage, updateMessage if needed
}

/** Repository for managing Observations. */
export interface IObservationRepository {
  addObservation(observation: Observation): Promise<void>;
  getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]>;
}

/** Repository for managing ThreadConfig and AgentState. */
export interface IStateRepository {
  getThreadConfig(threadId: string): Promise<ThreadConfig | null>;
  setThreadConfig(threadId: string, config: ThreadConfig): Promise<void>;
  getAgentState(threadId: string): Promise<AgentState | null>;
  setAgentState(threadId: string, state: AgentState): Promise<void>;
  // Potentially combine get/set into a single get/set ThreadContext method
  getThreadContext(threadId: string): Promise<ThreadContext | null>;
  setThreadContext(threadId: string, context: ThreadContext): Promise<void>;
}

/**
 * Represents the fully initialized and configured ART Framework client instance.
 * This object is the main entry point for interacting with the framework after setup.
 * It provides access to the core processing method and key subsystems.
 */
export interface ArtInstance {
    /** The main method to process a user query using the configured Agent Core. */
    readonly process: IAgentCore['process'];
    /** Accessor for the UI System, used to get sockets for subscriptions. */
    readonly uiSystem: UISystem;
    /** Accessor for the State Manager, used for managing thread configuration and state. */
    readonly stateManager: StateManager;
    /** Accessor for the Conversation Manager, used for managing message history. */
    readonly conversationManager: ConversationManager;
    /** Accessor for the Tool Registry, used for managing available tools. */
    readonly toolRegistry: ToolRegistry;
    /** Accessor for the Observation Manager, used for recording and retrieving observations. */
    readonly observationManager: ObservationManager;
    // Note: Direct access to other internal components like ReasoningEngine or StorageAdapter
    // is typically discouraged; interaction should primarily happen via the managers and process method.
}