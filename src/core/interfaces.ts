// src/core/interfaces.ts
import {
  AgentFinalResponse,
  AgentProps,
  CallOptions,
  ConversationMessage,
  ExecutionContext,
  FilterOptions,
  // FormattedPrompt, // Keep commented or remove later when ReasoningEngine is updated
  MessageOptions,
  MessageRole, // Added import
  Observation,
  ObservationFilter,
  ObservationType,
  ParsedToolCall,
  ThreadConfig,
  ThreadContext,
  ToolResult,
  ToolSchema, // Removed erroneous 'export type'
  AgentState,
  // --- Import new types (Refactor Phase 1) ---
  ArtStandardPrompt,
  // PromptContext, // Removed - No longer used by PromptManager interface
} from '@/types';

// Re-export types that might be needed by implementers of these core interfaces
export type {
  AgentFinalResponse,
  AgentProps,
  CallOptions,
  ConversationMessage,
  ExecutionContext,
  FilterOptions,
  MessageOptions,
  MessageRole,
  Observation,
  ObservationFilter,
  ObservationType,
  ParsedToolCall,
  ThreadConfig,
  ThreadContext,
  ToolResult,
  ToolSchema, // Ensure ToolSchema is re-exported
  AgentState,
  ArtStandardPrompt,
  StreamEvent, // Also re-export StreamEvent as it's used in ReasoningEngine
  LLMMetadata  // Also re-export LLMMetadata
} from '@/types';


/**
 * Interface for the central agent orchestrator.
 */
export interface IAgentCore {
  /**
   * Processes a user query through the configured agent reasoning pattern (e.g., PES).
   * Orchestrates interactions between various ART subsystems.
   * @param props - The input properties for the agent execution, including the query, thread ID, and injected dependencies.
   * @returns A promise that resolves with the final agent response and execution metadata.
   * @throws {ARTError} If a critical error occurs during orchestration that prevents completion.
   */
  process(props: AgentProps): Promise<AgentFinalResponse>;
}

/**
 * Interface for the component responsible for interacting with LLMs.
 */
export interface ReasoningEngine {
  /**
   * Executes a call to the configured Large Language Model (LLM).
   * This method is typically implemented by a specific `ProviderAdapter`.
   * When streaming is requested via `options.stream`, it returns an AsyncIterable
   * that yields `StreamEvent` objects as they are generated by the LLM provider.
   * When streaming is not requested, it should still return an AsyncIterable
   * that yields a minimal sequence of events (e.g., a single TOKEN event with the full response,
   * a METADATA event if available, and an END event).
   * @param prompt - The prompt to send to the LLM, potentially formatted specifically for the provider.
   * @param options - Options controlling the LLM call, including mandatory `threadId`, tracing IDs, model parameters (like temperature), streaming preference, and call context.
   * @returns A promise resolving to an AsyncIterable of `StreamEvent` objects.
   * @throws {ARTError} If a critical error occurs during the initial call setup or if the stream itself errors out (typically code `LLM_PROVIDER_ERROR`).
   */
  // TODO (Refactor): Update prompt type from FormattedPrompt to FormattedPromptResult['prompt'] in Phase 2
  call(prompt: import('@/types').FormattedPrompt, options: CallOptions): Promise<AsyncIterable<import("@/types").StreamEvent>>;
}

// --- PromptManager Interface (Refactor Phase 1) ---
/**
 * Interface for the stateless prompt assembler.
 * Uses a blueprint (template) and context provided by Agent Logic
 * to create a standardized prompt format (`ArtStandardPrompt`).
 */
export interface PromptManager {
    /**
     * Retrieves a named prompt fragment (e.g., a piece of instruction text).
     * Optionally allows for simple variable substitution if the fragment is a basic template.
     *
     * @param name - The unique identifier for the fragment.
     * @param context - Optional data for simple variable substitution within the fragment.
     * @returns The processed prompt fragment string.
     * @throws {ARTError} If the fragment is not found.
     */
    getFragment(name: string, context?: Record<string, any>): string; // Keep sync for now, assuming loaded at init

    /**
     * Validates a constructed prompt object against the standard schema.
     *
     * @param prompt - The ArtStandardPrompt object constructed by the agent.
     * @returns The validated prompt object (potentially after normalization if the schema does that).
     * @throws {ZodError} If validation fails (can be caught and wrapped in ARTError).
     */
    validatePrompt(prompt: ArtStandardPrompt): ArtStandardPrompt;

    /**
     * Assembles a prompt using a Mustache template (blueprint) and context data.
     * Renders the template with the provided context and parses the result as an ArtStandardPrompt.
     *
     * @param blueprint - The Mustache template containing the prompt structure.
     * @param context - The context data to inject into the template.
     * @returns A promise resolving to the assembled ArtStandardPrompt.
     * @throws {ARTError} If template rendering or JSON parsing fails.
     */
    assemblePrompt(blueprint: import('@/types').PromptBlueprint, context: import('@/types').PromptContext): Promise<ArtStandardPrompt>;

    // Future methods could include:
    // - loadFragmentsFromDir(directoryPath: string): Promise<void>;
    // - registerFragment(name: string, content: string): void;
}
// --- SystemPromptResolver Interface ---
/**
 * Resolves the final system prompt from base + instance/thread/call overrides
 * using tag+variables and merge strategies.
 */
export interface SystemPromptResolver {
  resolve(
    input: {
      base: string;
      instance?: string | import('@/types').SystemPromptOverride;
      thread?: string | import('@/types').SystemPromptOverride;
      call?: string | import('@/types').SystemPromptOverride;
    },
    traceId?: string
  ): Promise<string>;
}
// --- END PromptManager Interface ---


/**
 * Interface for parsing structured output from LLM responses.
 */
export interface OutputParser {
  /**
   * Parses the raw string output from the planning LLM call to extract structured information.
   * Implementations should be robust to variations in LLM output formatting.
   * @param output - The raw string response from the planning LLM call.
   * @returns A promise resolving to an object containing the extracted intent, plan description, and an array of parsed tool calls.
   * @throws {ARTError} If the output cannot be parsed into the expected structure (typically code `OUTPUT_PARSING_FAILED`).
   */
  parsePlanningOutput(output: string): Promise<{
    intent?: string;
    plan?: string;
    toolCalls?: ParsedToolCall[];
  }>;

  /**
   * Parses the raw string output from the synthesis LLM call to extract the final, user-facing response content.
   * This might involve removing extraneous tags or formatting.
   * @param output - The raw string response from the synthesis LLM call.
   * @returns A promise resolving to the clean, final response string.
   * @throws {ARTError} If the final response cannot be extracted (typically code `OUTPUT_PARSING_FAILED`).
   */
  parseSynthesisOutput(output: string): Promise<string>;
}

/**
 * Base interface for LLM Provider Adapters, extending the core ReasoningEngine.
 * Implementations will handle provider-specific API calls, authentication, etc.
 */
export interface ProviderAdapter extends ReasoningEngine {
  // Provider-specific methods or properties might be added here if needed.
  // The 'call' method implementation will be provider-specific.
  /** The unique identifier name for this provider (e.g., 'openai', 'anthropic'). */
  readonly providerName: string;

  /** Optional: Method for graceful shutdown */
  shutdown?(): Promise<void>;
}

/**
 * Interface for the executable logic of a tool.
 */
export interface IToolExecutor {
  /** The schema definition for this tool. */
  readonly schema: ToolSchema;

  /**
   * Executes the tool's logic.
   * @param input Validated input arguments matching the tool's inputSchema.
   * @param context Execution context containing threadId, traceId, etc.
   * @returns A promise resolving to the structured tool result.
   */
  execute(input: any, context: ExecutionContext): Promise<ToolResult>;
}

/**
 * Interface for managing the registration and retrieval of tools.
 */
export interface ToolRegistry {
  /**
   * Registers a tool executor instance, making it available for use.
   * @param executor - The instance of the class implementing `IToolExecutor`.
   * @throws {Error} If a tool with the same name is already registered.
   */
  registerTool(executor: IToolExecutor): Promise<void>;

  /**
   * Retrieves a registered tool executor instance by its unique name.
   * @param toolName - The `name` property defined in the tool's schema.
   * @returns A promise resolving to the executor instance, or `undefined` if no tool with that name is registered.
   */
  getToolExecutor(toolName: string): Promise<IToolExecutor | undefined>;

  /**
   * Retrieves the schemas of available tools. Can be filtered, e.g., to get only tools enabled for a specific thread.
   * @param filter - Optional filter criteria. If `enabledForThreadId` is provided, it should consult the `StateManager` to return only schemas for tools enabled in that thread's configuration.
   * @returns A promise resolving to an array of `ToolSchema` objects.
   */
  getAvailableTools(filter?: { enabledForThreadId?: string }): Promise<ToolSchema[]>;

  /**
   * Unregisters a tool by its unique name.
   * Implementations should silently succeed if the tool does not exist.
   */
  unregisterTool?(toolName: string): Promise<void>;

  /**
   * Unregisters multiple tools that match a predicate. Returns the number of tools removed.
   * This is useful for removing all tools belonging to a specific MCP server by name prefix.
   */
  unregisterTools?(predicate: (schema: ToolSchema) => boolean): Promise<number>;
}

/**
 * Interface for the system responsible for orchestrating tool execution.
 */
export interface ToolSystem {
  /**
   * Orchestrates the execution of a sequence of tool calls determined during the planning phase.
   * This involves verifying permissions, validating inputs, calling the tool executor, and recording observations.
   * @param toolCalls - An array of `ParsedToolCall` objects generated by the `OutputParser`.
   * @param threadId - The ID of the current thread, used for context and checking tool permissions via `StateManager`.
   * @param traceId - Optional trace ID for correlating observations.
   * @returns A promise resolving to an array of `ToolResult` objects, one for each attempted tool call (including errors).
   */
  executeTools(
    toolCalls: ParsedToolCall[],
    threadId: string,
    traceId?: string
  ): Promise<ToolResult[]>;
}

/**
 * Interface for managing thread-specific configuration and state.
 */
export interface StateManager {
  /**
   * Loads the complete context (`ThreadConfig` and `AgentState`) for a specific thread.
   * This is typically called at the beginning of an agent execution cycle.
   * @param threadId - The unique identifier for the thread.
   * @param userId - Optional user identifier, potentially used for retrieving user-specific state or config overrides.
   * @returns A promise resolving to the `ThreadContext` object containing the loaded configuration and state.
   * @throws {ARTError} If the context for the thread cannot be loaded (e.g., code `THREAD_NOT_FOUND`).
   */
  loadThreadContext(threadId: string, userId?: string): Promise<ThreadContext>;

  /**
   * Verifies if a specific tool is permitted for use within a given thread.
   * Checks against the `enabledTools` array in the thread's loaded `ThreadConfig`.
   * @param threadId - The ID of the thread.
   * @param toolName - The name of the tool to check.
   * @returns A promise resolving to `true` if the tool is enabled for the thread, `false` otherwise.
   */
  isToolEnabled(threadId: string, toolName: string): Promise<boolean>;

  /**
   * Retrieves a specific value from the thread's configuration (`ThreadConfig`).
   * Supports accessing nested properties using dot notation (e.g., 'reasoning.model').
   * @template T - The expected type of the configuration value.
   * @param threadId - The ID of the thread.
   * @param key - The key (potentially nested) of the configuration value to retrieve.
   * @returns A promise resolving to the configuration value, or `undefined` if the key doesn't exist or the thread config isn't loaded.
   */
  getThreadConfigValue<T>(threadId: string, key: string): Promise<T | undefined>;

  /**
   * Persists the `AgentState` for the thread, but only if it has been marked as modified during the current execution cycle.
   * This prevents unnecessary writes to the storage layer.
   * @param threadId - The ID of the thread whose state should potentially be saved.
   * @returns A promise that resolves when the save operation is complete (or skipped).
   */
  saveStateIfModified(threadId: string): Promise<void>;

  /**
   * Sets or completely replaces the configuration (`ThreadConfig`) for a specific thread.
   * Use with caution, as this overwrites the existing configuration. Consider methods for partial updates if needed.
   * @param threadId - The ID of the thread whose configuration is being set.
   * @param config - The complete `ThreadConfig` object to save.
   * @returns A promise that resolves when the configuration is saved.
   */
  setThreadConfig(threadId: string, config: ThreadConfig): Promise<void>;

  /**
   * Sets or updates the AgentState for a specific thread.
   * This method allows an agent to explicitly persist its internal state.
   * It requires that a ThreadConfig already exists for the thread, which is typically
   * ensured by the application calling setThreadConfig() prior to agent execution.
   * @param threadId - The unique identifier of the thread.
   * @param state - The AgentState object to save.
   * @returns A promise that resolves when the state is saved.
   * @throws {ARTError} If no ThreadConfig exists for the threadId, or if the repository fails.
   */
  setAgentState(threadId: string, state: AgentState): Promise<void>;

  /**
   * Enables specific tools for a conversation thread by adding them to the thread's enabled tools list.
   * This method loads the current thread configuration, updates the enabledTools array,
   * and persists the changes. Cache is invalidated to ensure fresh data on next load.
   * @param threadId - The unique identifier of the thread.
   * @param toolNames - Array of tool names to enable for this thread.
   * @returns A promise that resolves when the tools are enabled and configuration is saved.
   * @throws {ARTError} If no ThreadConfig exists for the threadId, or if the repository fails.
   */
  enableToolsForThread(threadId: string, toolNames: string[]): Promise<void>;

  /**
   * Disables specific tools for a conversation thread by removing them from the thread's enabled tools list.
   * This method loads the current thread configuration, updates the enabledTools array,
   * and persists the changes. Cache is invalidated to ensure fresh data on next load.
   * @param threadId - The unique identifier of the thread.
   * @param toolNames - Array of tool names to disable for this thread.
   * @returns A promise that resolves when the tools are disabled and configuration is saved.
   * @throws {ARTError} If no ThreadConfig exists for the threadId, or if the repository fails.
   */
  disableToolsForThread(threadId: string, toolNames: string[]): Promise<void>;

  /**
   * Gets the list of currently enabled tools for a specific thread.
   * This is a convenience method that loads the thread context and returns the enabledTools array.
   * @param threadId - The unique identifier of the thread.
   * @returns A promise that resolves to an array of enabled tool names, or empty array if no tools are enabled.
   * @throws {ARTError} If the thread context cannot be loaded.
   */
  getEnabledToolsForThread(threadId: string): Promise<string[]>;

  // Potentially add methods to update config/state if needed during runtime,
  // though v0.2.4 focuses on loading existing config.
  // updateAgentState(threadId: string, updates: Partial<AgentState>): Promise<void>;
}

/**
 * Interface for managing conversation history.
 */
export interface ConversationManager {
  /**
   * Appends one or more `ConversationMessage` objects to the history of a specific thread.
   * Typically called at the end of an execution cycle to save the user query and the final AI response.
   * @param threadId - The ID of the thread to add messages to.
   * @param messages - An array containing the `ConversationMessage` objects to add.
   * @returns A promise that resolves when the messages have been successfully added to storage.
   */
  addMessages(threadId: string, messages: ConversationMessage[]): Promise<void>;

  /**
   * Retrieves messages from a specific thread's history, usually in reverse chronological order.
   * @param threadId - The ID of the thread whose history is needed.
   * @param options - Optional parameters to control retrieval, such as `limit` (max number of messages) or `beforeTimestamp` (for pagination). See `MessageOptions` type.
   * @returns A promise resolving to an array of `ConversationMessage` objects, ordered according to the implementation (typically newest first if not specified otherwise).
   */
  getMessages(threadId: string, options?: MessageOptions): Promise<ConversationMessage[]>;

  // Optional: Method to clear history or prune based on limits might be useful.
  // clearHistory(threadId: string): Promise<void>;
}

/**
 * Interface for managing the recording and retrieval of observations.
 */
export interface ObservationManager {
  /**
   * Creates, persists, and broadcasts a new observation record.
   * This is the primary method used by other systems to log significant events.
   * It automatically generates a unique ID, timestamp, and potentially a title.
   * @param observationData - An object containing the core data for the observation (`threadId`, `type`, `content`, `metadata`, etc.), excluding fields generated by the manager (`id`, `timestamp`, `title`).
   * @returns A promise that resolves when the observation has been recorded and notified.
   */
  record(observationData: Omit<Observation, 'id' | 'timestamp' | 'title'>): Promise<void>;

  /**
   * Retrieves historical observations stored for a specific thread.
   * @param threadId - The ID of the thread whose observations are to be retrieved.
   * @param filter - Optional criteria to filter the observations, e.g., by `ObservationType`. See `ObservationFilter`.
   * @returns A promise resolving to an array of `Observation` objects matching the criteria.
   */
  getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]>;
}

/**
 * Generic interface for a typed publish/subscribe socket.
 */
export interface ITypedSocket<DataType, FilterType = any> {
  /**
   * Subscribes a callback function to receive data updates.
   * @param callback The function to call with new data.
   * @param filter Optional filter criteria specific to the socket type.
   * @param options Optional configuration like target threadId.
   * @returns An unsubscribe function.
   */
  subscribe(
    callback: (data: DataType) => void,
    filter?: FilterType,
    options?: { threadId?: string }
  ): () => void; // Returns unsubscribe function

  /**
   * Notifies subscribers of new data.
   * @param data The data payload.
   * @param options Optional targeting information (e.g., specific thread).
   */
  notify(
    data: DataType,
    options?: { targetThreadId?: string; targetSessionId?: string }
  ): void;

  /**
   * Optional method to retrieve historical data from the socket's source.
   * @param filter Optional filter criteria.
   * @param options Optional configuration like threadId and limit.
   */
  getHistory?(
    filter?: FilterType,
    options?: { threadId?: string; limit?: number }
  ): Promise<DataType[]>;
}

/**
 * TypedSocket specifically for Observation data.
 * FilterType is ObservationType or array of ObservationType.
 */
export interface ObservationSocket extends ITypedSocket<Observation, ObservationType | ObservationType[]> {}

/**
 * TypedSocket specifically for ConversationMessage data.
 * FilterType is MessageRole or array of MessageRole.
 */
export interface ConversationSocket extends ITypedSocket<ConversationMessage, MessageRole | MessageRole[]> {}

// Import concrete socket classes for use in the UISystem interface return types
import { ObservationSocket as ObservationSocketImpl } from '@/systems/ui/observation-socket';
import { ConversationSocket as ConversationSocketImpl } from '@/systems/ui/conversation-socket';

/**
 * Interface for the system providing access to UI communication sockets.
 */
export interface UISystem {
  /** Returns the singleton instance of the ObservationSocket. */
  getObservationSocket(): ObservationSocketImpl;
  /** Returns the singleton instance of the ConversationSocket. */
  getConversationSocket(): ConversationSocketImpl;
  /** Returns the singleton instance of the LLMStreamSocket. */
  getLLMStreamSocket(): import("@/systems/ui/llm-stream-socket").LLMStreamSocket;
  /** Returns the singleton instance of the A2ATaskSocket. */
  getA2ATaskSocket(): import("@/systems/ui/a2a-task-socket").A2ATaskSocket;
  // TODO: Potentially add getStateSocket(): StateSocket; in the future
}

/**
 * Interface for a storage adapter, providing a generic persistence layer.
 */
export interface StorageAdapter {
  /** Optional initialization method (e.g., connecting to DB). */
  init?(config?: any): Promise<void>;

  /**
   * Retrieves a single item from a collection by its ID.
   * @param collection The name of the data collection (e.g., 'conversations', 'observations').
   * @param id The unique ID of the item.
   * @returns The item or null if not found.
   */
  get<T>(collection: string, id: string): Promise<T | null>;

  /**
   * Saves (creates or updates) an item in a collection.
   * @param collection The name of the collection.
   * @param id The unique ID of the item.
   * @param data The data to save.
   */
  set<T>(collection: string, id: string, data: T): Promise<void>;

  /**
   * Deletes an item from a collection by its ID.
   * @param collection The name of the collection.
   * @param id The unique ID of the item.
   */
  delete(collection: string, id: string): Promise<void>;

  /**
   * Queries items in a collection based on filter options.
   * @param collection The name of the collection.
   * @param filterOptions Filtering, sorting, and pagination options.
   * @returns An array of matching items.
   */
  query<T>(collection: string, filterOptions: FilterOptions): Promise<T[]>;

  /** Optional: Clears all items from a specific collection. */
  clearCollection?(collection: string): Promise<void>;

  /** Optional: Clears all data managed by the adapter. Use with caution! */
  clearAll?(): Promise<void>;
}

// --- Repository Interfaces ---
// These interfaces define how specific data types are managed, using a StorageAdapter internally.

/** Repository for managing ConversationMessages. */
export interface IConversationRepository {
  addMessages(threadId: string, messages: ConversationMessage[]): Promise<void>;
  getMessages(threadId: string, options?: MessageOptions): Promise<ConversationMessage[]>;
  // Potentially add deleteMessage, updateMessage if needed
}

/** Repository for managing Observations. */
export interface IObservationRepository {
  addObservation(observation: Observation): Promise<void>;
  getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]>;
}

/** Repository for managing ThreadConfig and AgentState. */
export interface IStateRepository {
  getThreadConfig(threadId: string): Promise<ThreadConfig | null>;
  setThreadConfig(threadId: string, config: ThreadConfig): Promise<void>;
  getAgentState(threadId: string): Promise<AgentState | null>;
  setAgentState(threadId: string, state: AgentState): Promise<void>;
  // Potentially combine get/set into a single get/set ThreadContext method
  getThreadContext(threadId: string): Promise<ThreadContext | null>;
  setThreadContext(threadId: string, context: ThreadContext): Promise<void>;
}

/**
 * Interface for managing A2A (Agent-to-Agent) task persistence and retrieval.
 */
export interface IA2ATaskRepository {
  /**
   * Creates a new A2A task in the repository.
   * @param task - The A2ATask object to create.
   * @returns A promise that resolves when the task is successfully stored.
   * @throws {ARTError} If the task cannot be created (e.g., duplicate taskId, validation errors).
   */
  createTask(task: import('@/types').A2ATask): Promise<void>;

  /**
   * Retrieves an A2A task by its unique identifier.
   * @param taskId - The unique identifier of the task.
   * @returns A promise resolving to the A2ATask object if found, or null if not found.
   * @throws {ARTError} If an error occurs during retrieval.
   */
  getTask(taskId: string): Promise<import('@/types').A2ATask | null>;

  /**
   * Updates an existing A2A task with new information.
   * @param taskId - The unique identifier of the task to update.
   * @param updates - Partial A2ATask object containing the fields to update.
   * @returns A promise that resolves when the task is successfully updated.
   * @throws {ARTError} If the task is not found or cannot be updated.
   */
  updateTask(taskId: string, updates: Partial<import('@/types').A2ATask>): Promise<void>;

  /**
   * Removes an A2A task from the repository.
   * @param taskId - The unique identifier of the task to delete.
   * @returns A promise that resolves when the task is successfully deleted.
   * @throws {ARTError} If the task is not found or cannot be deleted.
   */
  deleteTask(taskId: string): Promise<void>;

  /**
   * Retrieves tasks associated with a specific thread.
   * @param threadId - The thread identifier to filter tasks.
   * @param filter - Optional filter criteria for task status, priority, or assigned agent.
   * @returns A promise resolving to an array of A2ATask objects matching the criteria.
   */
  getTasksByThread(threadId: string, filter?: {
    status?: import('@/types').A2ATaskStatus | import('@/types').A2ATaskStatus[];
    priority?: import('@/types').A2ATaskPriority;
    assignedAgentId?: string;
  }): Promise<import('@/types').A2ATask[]>;

  /**
   * Retrieves tasks assigned to a specific agent.
   * @param agentId - The agent identifier to filter tasks.
   * @param filter - Optional filter criteria for task status or priority.
   * @returns A promise resolving to an array of A2ATask objects assigned to the agent.
   */
  getTasksByAgent(agentId: string, filter?: {
    status?: import('@/types').A2ATaskStatus | import('@/types').A2ATaskStatus[];
    priority?: import('@/types').A2ATaskPriority;
  }): Promise<import('@/types').A2ATask[]>;

  /**
   * Retrieves tasks based on their current status.
   * @param status - The task status(es) to filter by.
   * @param options - Optional query parameters like limit and pagination.
   * @returns A promise resolving to an array of A2ATask objects with the specified status.
   */
  getTasksByStatus(
    status: import('@/types').A2ATaskStatus | import('@/types').A2ATaskStatus[],
    options?: { limit?: number; offset?: number }
  ): Promise<import('@/types').A2ATask[]>;
}

/**
 * Interface for an authentication strategy that can provide authorization headers.
 * This enables pluggable security for remote service connections (MCP servers, A2A agents, etc.)
 */
export interface IAuthStrategy {
  /**
   * Asynchronously retrieves the authentication headers.
   * This might involve checking a cached token, refreshing it if expired, and then returning it.
   * @returns A promise that resolves to a record of header keys and values.
   * @throws {ARTError} If authentication fails or cannot be obtained.
   */
  getAuthHeaders(): Promise<Record<string, string>>;

  /** Optional: Initiates the login flow for the strategy. */
  login?(): Promise<void>;

  /** Optional: Handles the redirect from the authentication server. */
  handleRedirect?(): Promise<void>;

  /** Optional: Logs the user out. */
  logout?(): void;

  /** Optional: Checks if the user is authenticated. */
  isAuthenticated?(): Promise<boolean>;
}

import { AuthManager } from '@/systems/auth/AuthManager';

export interface ArtInstance {
    /** The main method to process a user query using the configured Agent Core. */
    readonly process: IAgentCore['process'];
    /** Accessor for the UI System, used to get sockets for subscriptions. */
    readonly uiSystem: UISystem;
    /** Accessor for the State Manager, used for managing thread configuration and state. */
    readonly stateManager: StateManager;
    /** Accessor for the Conversation Manager, used for managing message history. */
    readonly conversationManager: ConversationManager;
    /** Accessor for the Tool Registry, used for managing available tools. */
    readonly toolRegistry: ToolRegistry;
    /** Accessor for the Observation Manager, used for recording and retrieving observations. */
    readonly observationManager: ObservationManager;
    /** Accessor for the Auth Manager, used for handling authentication. */
    readonly authManager?: AuthManager | null;
    // Note: Direct access to other internal components like ReasoningEngine or StorageAdapter
    // is typically discouraged; interaction should primarily happen via the managers and process method.
}