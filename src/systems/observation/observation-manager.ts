import { ObservationManager as ObservationManagerInterface, IObservationRepository } from '@/core/interfaces'; // Import the interface defined in core/interfaces
import { ObservationSocket } from '../ui/observation-socket'; // Import the class implementation
import { Observation, ObservationFilter } from '@/types'; // Kept ObservationType and Omit removed
import { generateUUID } from '@/utils/uuid'; // Assuming UUID utility exists as per Phase 0.9
import { Logger } from '@/utils/logger'; // Import Logger

/**
 * Manages the lifecycle of agent observations: creation, persistence, retrieval, and notification.
 *
 * @remarks
 * It provides methods to record and retrieve observations, which are crucial for
 * debugging, monitoring, and analyzing agent behavior. The manager uses a
 * repository pattern to abstract the underlying storage mechanism.
 *
 * @see {@link ObservationManagerInterface} for the interface definition.
 * @see {@link IObservationRepository} for the storage repository interface.
 */
export class ObservationManager implements ObservationManagerInterface { // Implement the imported interface
    private observationRepository: IObservationRepository;
    private observationSocket: ObservationSocket;

    /**
     * Creates an instance of ObservationManager.
     *
     * @param observationRepository The repository for persisting observations.
     * @param observationSocket The socket for notifying UI about new observations.
     */
    constructor(observationRepository: IObservationRepository, observationSocket: ObservationSocket) {
        this.observationRepository = observationRepository;
        this.observationSocket = observationSocket;
    }

    /**
     * Creates, persists, and broadcasts a new observation record based on the provided data.
     *
     * @remarks
     * Automatically generates a unique `id`, `timestamp`, and a default `title`.
     * Uses the injected {@link IObservationRepository} for persistence and {@link ObservationSocket} for notification.
     *
     * @param observationData An object containing the core data for the observation (`threadId`, `type`, `content`, `metadata`, etc.), excluding fields generated by the manager (`id`, `timestamp`, `title`).
     * @returns A promise that resolves when the observation has been successfully saved and notified, or rejects if a critical error occurs during persistence. Notification errors are logged but generally do not cause rejection.
     */
    async record(observationData: Omit<Observation, 'id' | 'timestamp' | 'title'>): Promise<void> { // Corrected Omit and Promise syntax
        const observation: Observation = {
            ...observationData,
            id: generateUUID(),
            timestamp: Date.now(),
            // Generate a simple title based on the type for now
            title: `${observationData.type} Recorded`,
        };

        try {
            await this.observationRepository.addObservation(observation); // Assuming addObservation exists on IObservationRepository
            // Use the generic notify method from TypedSocket interface
            Logger.debug(`[ObservationManager] Notifying ObservationSocket for obsId: ${observation.id}, type: ${observation.type}`); // Log before notify
            this.observationSocket.notify(observation, { targetThreadId: observation.threadId });
            Logger.debug(`[ObservationManager] ObservationSocket notified for obsId: ${observation.id}`); // Log after notify
        } catch (error) {
            console.error("Error recording observation:", error);
            // Decide on error handling strategy - rethrow, log, or generate an ERROR observation?
            // For now, just logging. Consider adding an ERROR observation itself.
            throw error; // Rethrowing for now so the caller is aware
        }
    }

    /**
     * Retrieves historical observations stored for a specific thread, using the repository.
     *
     * @remarks
     * Allows filtering based on criteria defined in {@link ObservationFilter}.
     *
     * @param threadId The ID of the thread whose observations are to be retrieved.
     * @param filter Optional criteria (`ObservationFilter`) to filter the observations (e.g., by type, timestamp).
     * @returns A promise resolving to an array of {@link Observation} objects matching the criteria.
     * @throws If the repository encounters an error during retrieval.
     */
    async getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]> {
        try {
            // Assuming repository has a 'findObservations' method that accepts threadId and filter
            // Assuming repository has a method matching this signature
            return await this.observationRepository.getObservations(threadId, filter); // Assuming repository method is getObservations
        } catch (error) {
            console.error(`Error retrieving observations for thread ${threadId}:`, error);
            throw error; // Rethrowing for now
        }
    }
}