import { ObservationManager as ObservationManagerInterface, IObservationRepository } from '../../core/interfaces'; // Import the interface defined in core/interfaces
import { ObservationSocket } from '../ui/observation-socket'; // Import the class implementation
import { Observation, ObservationFilter } from '../../types'; // Kept ObservationType and Omit removed
import { generateUUID } from '../../utils/uuid'; // Assuming UUID utility exists as per Phase 0.9

/**
 * Manages the lifecycle of agent observations: creation, persistence, retrieval, and notification.
 * It acts as the central service for logging significant events during agent execution.
 * Implements the `ObservationManager` interface defined in core interfaces.
 */
export class ObservationManager implements ObservationManagerInterface { // Implement the imported interface
    private observationRepository: IObservationRepository;
    private observationSocket: ObservationSocket;

    /**
     * Creates an instance of ObservationManager.
     * @param observationRepository - The repository for persisting observations.
     * @param observationSocket - The socket for notifying UI about new observations.
     */
    constructor(observationRepository: IObservationRepository, observationSocket: ObservationSocket) {
        this.observationRepository = observationRepository;
        this.observationSocket = observationSocket;
    }

    /**
     * Creates, persists, and broadcasts a new observation record based on the provided data.
     * Automatically generates a unique `id`, `timestamp`, and a default `title`.
     * Uses the injected `IObservationRepository` for persistence and `ObservationSocket` for notification.
     * @param observationData - An object containing the core data for the observation (`threadId`, `type`, `content`, `metadata`, etc.), excluding fields generated by the manager (`id`, `timestamp`, `title`).
     * @returns A promise that resolves when the observation has been successfully saved and notified, or rejects if a critical error occurs during persistence. Notification errors are logged but generally do not cause rejection.
     */
    async record(observationData: Omit<Observation, 'id' | 'timestamp' | 'title'>): Promise<void> { // Corrected Omit and Promise syntax
        const observation: Observation = {
            ...observationData,
            id: generateUUID(),
            timestamp: Date.now(),
            // Generate a simple title based on the type for now
            title: `${observationData.type} Recorded`,
        };

        try {
            await this.observationRepository.addObservation(observation); // Assuming addObservation exists on IObservationRepository
            // Use the generic notify method from TypedSocket interface
            this.observationSocket.notify(observation, { targetThreadId: observation.threadId });
        } catch (error) {
            console.error("Error recording observation:", error);
            // Decide on error handling strategy - rethrow, log, or generate an ERROR observation?
            // For now, just logging. Consider adding an ERROR observation itself.
            throw error; // Rethrowing for now so the caller is aware
        }
    }

    /**
     * Retrieves historical observations stored for a specific thread, using the repository.
     * Allows filtering based on criteria defined in `ObservationFilter`.
     * @param threadId - The ID of the thread whose observations are to be retrieved.
     * @param filter - Optional criteria (`ObservationFilter`) to filter the observations (e.g., by type, timestamp).
     * @returns A promise resolving to an array of `Observation` objects matching the criteria.
     * @throws {Error} If the repository encounters an error during retrieval.
     */
    async getObservations(threadId: string, filter?: ObservationFilter): Promise<Observation[]> {
        try {
            // Assuming repository has a 'findObservations' method that accepts threadId and filter
            // Assuming repository has a method matching this signature
            return await this.observationRepository.getObservations(threadId, filter); // Assuming repository method is getObservations
        } catch (error) {
            console.error(`Error retrieving observations for thread ${threadId}:`, error);
            throw error; // Rethrowing for now
        }
    }
}